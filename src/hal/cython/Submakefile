

HALNGDIR := hal/cython
HALNGMKDIR :=  $(HALNGDIR)/machinekit

PYTARGETS += ../lib/python/machinekit/__init__.py

../lib/python/machinekit/__init__.py:
	@mkdir -p ../lib/python/machinekit
	@touch $@

INCLUDES += $(HALNGDIR)

HALSO_CSRCS := $(addprefix $(HALNGMKDIR)/, \
	hal.c)
HALSO_CXXSRCS := \
	hal/utils/halcmd_rtapiapp.cc
HALSO_OBJS = $(call TOOBJS, $(HALSO_CSRCS) $(HALSO_CXXSRCS))

USERSRCS += $(HALSO_CSRCS)
$(call TOOBJSDEPS, $(HALSO_CSRCS) $(HALSO_CXXSRCS)) : \
	EXTRAFLAGS=-fPIC -Ihal/utils -I.

ifeq ($(HAVE_CYTHON),yes)
# shotgun approach to dependencies: will alwas hit the target (and more).
$(HALNGMKDIR)/hal.c: $(wildcard $(HALNGMKDIR)/*.pyx $(HALNGMKDIR)/*.pxd)
endif

CYTHON_TARGETS += ../lib/python/machinekit/hal.so
../lib/python/machinekit/hal.so: $(HALSO_OBJS) ../lib/liblinuxcnchal.so.0
	$(ECHO) Linking python module $(notdir $@)
	@mkdir -p $(dir $@)
	$(Q)$(CC) $(LDFLAGS) -shared -o $@ $^ $(CZMQ_LIBS)


RTAPISO_CSRCS := $(addprefix $(HALNGMKDIR)/, \
	rtapi_bindings.c)
RTAPISO_CXXSRCS := \
	hal/utils/halcmd_rtapiapp.cc
RTAPISO_OBJS = $(call TOOBJS, $(RTAPISO_CSRCS) $(RTAPISO_CXXSRCS))

ifeq ($(HAVE_CYTHON),yes)
$(RTAPISO_CSRCS): $(wildcard $(HALNGMKDIR)/*.pyx $(HALNGMKDIR)/*.pxd)
endif

USERSRCS += $(RTAPISO_CSRCS) $(RTAPISO_CXXSRCS)
$(call TOOBJSDEPS, $(RTAPISO_CSRCS) $(RTAPISO_CXXSRCS)) : \
	EXTRAFLAGS=-fPIC -Ihal/utils -I.

CYTHON_TARGETS += ../lib/python/machinekit/rtapi/rtapi_bindings.so

../lib/python/machinekit/rtapi/rtapi_bindings.so: $(RTAPISO_OBJS) \
		../lib/liblinuxcnchal.so.0 \
		../lib/liblinuxcnc-pb2++.so.0
	$(ECHO) Linking python module $(notdir $@)
	@mkdir -p $(dir $@)
	$(Q)$(CC) -g $(LDFLAGS) -shared -o $@ $^ $(CZMQ_LIBS)


COMPATSO_CSRCS := $(addprefix $(HALNGMKDIR)/, \
	compat_bindings.c)
COMPATSO_OBJS = $(call TOOBJS, $(COMPATSO_CSRCS))

ifeq ($(HAVE_CYTHON),yes)
$(COMPATSO_CSRCS): $(wildcard $(HALNGMKDIR)/*.pyx $(HALNGMKDIR)/*.pxd)
endif

USERSRCS += $(COMPATSO_CSRCS)
$(call TOOBJSDEPS, $(COMPATSO_CSRCS)) : EXTRAFLAGS=-fPIC

CYTHON_TARGETS += ../lib/python/machinekit/compat/compat_bindings.so

../lib/python/machinekit/compat/compat_bindings.so: $(COMPATSO_OBJS) \
		../lib/liblinuxcnchal.so.0
	$(ECHO) Linking python module $(notdir $@)
	@mkdir -p $(dir $@)
	$(Q)$(CC) -g $(LDFLAGS) -shared -o $@ $^



SHMCOMMONSO_CSRCS := $(addprefix $(HALNGMKDIR)/, \
	shmcommon.c ) \
	rtapi/shmdrv/shmdrvapi.c
SHMCOMMONSO_OBJS = $(call TOOBJS, $(SHMCOMMONSO_CSRCS))

USERSRCS += $(SHMCOMMONSO_CSRCS)
$(call TOOBJSDEPS, $(SHMCOMMONSO_CSRCS)) : EXTRAFLAGS=-fPIC -Irtapi/shmdrv

CYTHON_TARGETS += ../lib/python/machinekit/shmcommon.so

../lib/python/machinekit/shmcommon.so: $(SHMCOMMONSO_OBJS)
	$(ECHO) Linking python module $(notdir $@)
	@mkdir -p $(dir $@)
	$(Q)$(CC) -g  -shared -o $@ $^ $(LDFLAGS) -lrt

# This conditional should disappear someday when Cython v. 0.19+ is
# available in common, current distros.
ifeq ($(HAVE_CYTHON),yes)
$(patsubst %.pyx, %.c, $(wildcard $(HALNGMKDIR)/*.pyx)): \
$(HALNGDIR)/machinekit/%.c: $(addprefix $(HALNGDIR)/machinekit/, %.pyx %.pxd)
	$(ECHO) Cythoning $(notdir $@)
	$(Q)$(CYTHON) -o $@ $<
else
$(patsubst %.pyx, %.c, $(wildcard $(HALNGMKDIR)/*.pyx)): \
$(HALNGDIR)/machinekit/%.c: $(HALNGDIR)/machinekit/attic/%.c
	$(ECHO) Copying cython $(notdir $@)
	$(Q)cp $< $@
endif
